# 将我们的成果封装成库

## 前言

​	这里应该算是笔者的教程和其他的教程并不太一样的地方，基本上全程都只是零星的教会你如何使用这些器件和外设后，就基本上不会再有其他内容了，但是笔者想说的是，一个比较好的封装和抽象有的时候可以帮助自己省力无穷。请看笔者的一个LED电灯程序

```c
#include "gpio.h"
#include "system_clock.h"

static void __open_clk(CCGPIOType* type)
{
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
}

static void __post_init(CCGPIOType* type)
{
	set_ccgpio_pinstate(type, CCGPIO_HIGH);
}

CCGPIO_InitType	initer = {
	.clk_open = __open_clk,
	.post_init = __post_init,
	.port = GPIOC,
	.initer = {
		.GPIO_Mode = GPIO_Mode_Out_PP,
		.GPIO_Speed = GPIO_Speed_50MHz,
		.GPIO_Pin = GPIO_Pin_13
	}
};

int main(void)
{
	CCGPIOType	type;
	configure_ccgpio(&type, &initer);
	
	while (1)
	{
		reverse_ccgpio_pinstate(&type);
		system_delay_ms(500);
	}
}
```

​	对于一个这样的程序，笔者分离了初始化配置和初始化的流程，而且配备了潜在的后置初始化，另一方面，他强制的迫使你理清楚这些外设的初始化的流程，在你完成了学习后，你应当会对这些代码做简单的封装，而不是直接cv代码就满足。

​	下面，我们就让从0开始，构建一套自己的库出来！

## 小试身手：从LED开始

​	我们的事业将会从LED开始，在前几篇博客，我认为我都快把嘴皮子给磨烂了的说：对于GPIO操作，我们第一步是开启时钟，第二步是封装配置，第三步是操作GPIO。

​	库封装的几个基本步骤是如下的，他跟写程序类似，但是又不局限于此。

### STEP1：理清楚被抽象对象的工作原理

​	这个事情咱们上面就聊过了，我们的抽象对象到目前为止，只是GPIO本身的抽象。所以我们要做的也就是使用结构体抽象GPIO（可以用纯粹的过程式函数，这个度看你）。一般而言，我们在绝大部分情况下，只会关心GPIO的分组和引脚，也就是

```c
/**
 * @brief this is a simple minial gpio type
 */
typedef struct __gpiomintype{
    GPIO_TypeDef*       port;   ///<    gpio port
    GPIO_PinType        pin;    ///<    gpio pin
}CCGPIOType;

/**
 * @brief this is a initer of gpio
 */
typedef struct __gpiofullinit{
    OpenClock               clk_open;   ///< we need to provide a open clock as neccessities
    GPIOPostInit            post_init;  ///< as optional choices as some init don't require the post init
    GPIO_TypeDef*           port;       ///< Memorize the port we open clk
    GPIO_InitTypeDef        initer;     ///< initer of the gpio type
}CCGPIO_InitType;
```

​	这样我们操作的时候，就可以有了分组。我们的CCGPIOType拿到手，你就认为我们掌握了单片机上的一个GPIO。之后我们还会构建很多其他的东西的库，但是这都需要你理解了原理之后，我们才要做

> 库的构建不能一蹴而就，你写的史山代码都要经过一次次的重构直到逐步可以处理绝大多的情况，所以，需要对自己构建的东西掌握一个度，不可以一下把事情全部“想完”（构建过多富裕的抽象）和一点事情“不想”（没有抽象），这个事情是需要大家对自己的目标客体有所理解后才能行动，这就是为什么我现在才会提这个事情

### STEP2：理清楚对象的基本暴露功能

​	一个对象，对于嵌入式的而言，必须要做的就是将自己可以做什么广而告之。比如说，我们可以读取和设置GPIO的电平。

```c
/**
 * @brief this configures the GPIO, make settings in the CCGPIO_InitType
 * 
 * @param[out]  type    containers for the gpio, you can pass NULL for unused handle
 * @param[in]   initer  must be passed for telling how to init the issue
 */
void configure_ccgpio(CCGPIOType* type, CCGPIO_InitType* initer);

/**
 * @brief   this is a simple enum of the PinState, 
 *          As expected:
 *          CCGPIO_LOW offer a low level output
 *          CCGPIO_HIGH offer a high level output
 */
typedef enum{
    CCGPIO_LOW,
    CCGPIO_HIGH
}CCGPIO_PinState;

/**
 * @brief Set the ccgpio pinstate object for a concrete gpio level
 * 
 * @param[in] type  gpio_handle
 * @param[in] state states of the gpio pinstate
 */
void set_ccgpio_pinstate(CCGPIOType* type, CCGPIO_PinState state);

/**
 * @brief reverse the gpio pin state, or we say: toggle the pin!
 * 
 * @param type gpio_handle
 */
void reverse_ccgpio_pinstate(CCGPIOType* type);
```

> 上面的这些文档是doyxgen生成的，这也是笔者喜欢使用Vscode开发的原因，非常的爽

​	一个对象一定要在逻辑上经历构造（创建/使能/使得对象变得可用）和析构（销毁/失能/使得对象不可以在被用），就像你拿出焊笔，显然需要加热后才能用（构造），当你不用的时候，也是要断电（析构）而不是让他热在那里。

​	当然，我们这个库非常的简单，暂时不考虑析构的事情（程序并不复杂，基本上所有的外设需要一直工作），因此，我们不会设置析构的函数，感兴趣的朋友可以了解一下GPIO_DeInit来关闭时钟。我们上面的接口，也就只留下一个初始化GPIO的接口configure_ccgpio

​	比如说，我们会希望GPIO可以被设置电平，翻转电平（对于LED而言，并不需要读取电平），这也是为什么我们会暴露这些接口。

### STEP3：逐一的按照流程实现这些接口

​	下一步就是按照我们的流程把这些接口实现了。

```c
/**
 * @brief this configures the GPIO, make settings in the CCGPIO_InitType
 * 
 * @param[out]  type    containers for the gpio, you can pass NULL for unused handle
 * @param[in]   initer  must be passed for telling how to init the issue
 */
void configure_ccgpio(CCGPIOType* type, CCGPIO_InitType* initer)
{
    CCGPIOType cached;
    cached.pin = initer->initer.GPIO_Pin;
    cached.port = initer->port;
    initer->clk_open(type);
    GPIO_Init(initer->port, &initer->initer);
    if(type){
        *type = cached;
    }
    if(initer->post_init){
        initer->post_init(&cached);
    }
}
```

​	我们上面的配置就完成了设置，回顾一下流程，我们开启时钟：`initer->clk_open(type);`，配置并上传我们的工作`GPIO_Init(initer->port, &initer->initer);`，而且如果我们立马设置GPIO的电平让他有一些初始化的默认操作的时候，我们还有接口`post_init`。

### STEP4：测试你的库封装

```c
#include "gpio.h"
#include "system_clock.h"

static void __open_clk(CCGPIOType* type)
{
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE);
}

static void __post_init(CCGPIOType* type)
{
	set_ccgpio_pinstate(type, CCGPIO_HIGH);
}

CCGPIO_InitType	initer = {
	.clk_open = __open_clk,
	.post_init = __post_init,
	.port = GPIOC,
	.initer = {
		.GPIO_Mode = GPIO_Mode_Out_PP,
		.GPIO_Speed = GPIO_Speed_50MHz,
		.GPIO_Pin = GPIO_Pin_13
	}
};

int main(void)
{
	CCGPIOType	type;
	configure_ccgpio(&type, &initer);
	
	while (1)
	{
		reverse_ccgpio_pinstate(&type);
		system_delay_ms(500);
	}
}
```

​	此时此刻，在PC13上外界一个LED，他就会闪烁。

## 你的任务

- 笔者没有给出set_ccgpio_pinstate的实现，对于标准库，请你使用GPIO_WriteBit完成抽象

- 笔者没有给出reverse_ccgpio_pinstate的实现，标准库没有提供GPIO翻转电平的抽象，请你回忆上一篇文章中笔者对GPIO的ODR寄存器，BRR寄存器和BSRR寄存器的介绍，自己实现一个电平翻转的函数，且测试。

- 复用是一个非常重要的理念，笔者没有讲授，是因为他必须结合实际进行探讨，复用在编程中，指代的是使用已有的东西完成没有的东西。我们直到按钮的读取无非就是将GPIO配置为输入模式，当用户想要直到按钮是否按下的时候，调用一个函数（比方说isKeyPressed函数），返回一个值，指代当调用这个函数的时候，按钮是按下了还是没按下。必须要保证你的签名是如下的：

  ```
  uint8_t isKeyPressed(KeyHandle* handle);	// KeyHandle是一个基于ccgpiopin的结构体
  ```

- 所有的代码都在笔者的代码仓库：[BetterATK/103c8t6/standard at STM32F1 · Charliechen114514/BetterATK](https://github.com/Charliechen114514/BetterATK/tree/STM32F1/103c8t6/standard)





